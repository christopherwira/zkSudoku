import "utils/casts/u32_to_field" as u32_to_field;

// This function defines the constraints for a valid 9x9 Sudoku solution.
// The 'solution' is the user's private input (their complete 9x9 grid).
// The 'board' is the public input (the initial puzzle with 0s for empty cells).
def main(private field[9][9] solution, public field[9][9] board) {

    // --- Constraint 1: Each cell value must be between 1 and 9 ---
    // We use a common ZKP trick: for a value 'v', the expression
    // (v-1)*(v-2)*...*(v-9) will only equal 0 if 'v' is one of the numbers 1-9.
    for u32 i in 0..9 {
        for u32 j in 0..9 {
            field mut product = 1;
            for u32 k in 1..10 {
                field k_field = u32_to_field(k);
                product = product * (solution[i][j] - k_field);
            }
            assert(product == 0); // Assert that the product is zero.
        }
    }

    // --- Constraint 2: The private solution must respect the public board's clues ---
    // If a cell on the public board is not 0, it's a clue. The corresponding
    // cell in the private solution MUST be equal to it.
    for u32 i in 0..9 {
        for u32 j in 0..9 {
            // This constraint is only enforced if board[i][j] is not 0.
            assert((solution[i][j] - board[i][j]) * board[i][j] == 0);
        }
    }

    // --- Constraint 3 & 4: Each row and each column must contain unique numbers ---
    // We check that the sum of each row/column is 45 (the sum of 1 to 9).
    // Combined with the range check (Constraint 1), this proves that each number
    // from 1 to 9 appears exactly once.
    for u32 i in 0..9 {
        field mut row_sum = 0;
        field mut col_sum = 0;
        for u32 j in 0..9 {
            row_sum = row_sum + solution[i][j];
            col_sum = col_sum + solution[j][i];
        }
        assert(row_sum == 45);
        assert(col_sum == 45);
    }

    // --- Constraint 5: Each 3x3 subgrid must contain unique numbers ---
    // We apply the same sum check to each of the nine 3x3 boxes.
    for u32 box_row_start in 0..3 {
        for u32 box_col_start in 0..3 {
            field mut box_sum = 0;
            for u32 i in 0..3 {
                for u32 j in 0..3 {
                    box_sum = box_sum + solution[box_row_start * 3 + i][box_col_start * 3 + j];
                }
            }
            assert(box_sum == 45);
        }
    }
}
